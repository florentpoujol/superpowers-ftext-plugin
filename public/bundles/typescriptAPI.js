(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){


SupCore.system.registerPlugin("typescriptAPI", "fText", {
  code: "/// <reference path=\"Sup.d.ts\"/>\r\n\r\n/* tslint:disable:class-name */\r\nclass fText extends Sup.Asset {\r\n\r\n  /**\r\n  * Holds the following parsers :<br>\r\n  * - https://github.com/zaach/jsonlint <br>\r\n  * - https://github.com/groupon/cson-parser<br>\r\n  * - https://github.com/component/domify<br>\r\n  * - https://github.com/evilstreak/markdown-js<br>\r\n  * - https://github.com/stylus/stylus<br>\r\n  * - https://github.com/nodeca/js-yaml\r\n  */\r\n  static parsers: {\r\n    jsonlint: any,\r\n    csonparser: any,\r\n    domify: (text: string) => any,\r\n    markdown: any,\r\n    pug: any,\r\n    stylus: any,\r\n    jsyaml: any\r\n  } = (window as any).fTextParsers;\r\n  // (window as any).fTextParsers is set in runtime/fText.ts\r\n\r\n  /**\r\n  * The set of instructions which can be found in the asset's content.\r\n  */\r\n  private instructions: { [key: string]: string|string[] } = {};\r\n\r\n  /**\r\n  * The asset's extension (if any) found at the end of its name.\r\n  */\r\n  private extension: string = \"\";\r\n\r\n  // ----------------------------------------\r\n\r\n  // called from runtime createdOuterAsset(), or by hand\r\n  // inner is the asset's pub as defined in the asset's class\r\n  /**\r\n  * @param inner - The asset's pub as defined in the asset's class.\r\n  */\r\n  constructor(inner: {[key : string]: any; }) {\r\n    super(inner); // sets inner as the value of this.__inner\r\n\r\n    this._parseInstructions();\r\n\r\n    // get asset's extension\r\n    let assetName = this.__inner.name; // 06/09/15 where does this.__inner.name come from ? is it the path ?  it comes from the runtime loadAsset() where entry\r\n    let extensionMatches = assetName.match(/\\.[a-zA-Z]+$/gi); // look for any letter after a dot at the end of the string\r\n    if (extensionMatches != null)\r\n      this.extension = extensionMatches[0].replace(\".\", \"\");\r\n  }\r\n\r\n  /**\r\n  * Read the [ftext: instruction: value] instructions in the asset's text\r\n  * then build the this.instructions object.\r\n  * Called once from the constructor\r\n  */\r\n  private _parseInstructions() {\r\n    let regex = /ftext:([a-zA-Z0-9\\/+-]+)(:([a-zA-Z0-9\\.\\/+-]+))?/ig;\r\n    let match: any;\r\n    let instructionsCount = (this.__inner.text.match(/ftext/ig) || []).length; // prevent infinite loop\r\n    do {\r\n      match = regex.exec(this.__inner.text);\r\n      if (match != null && match[1] != null) {\r\n        let name = match[1].trim().toLowerCase();\r\n        let value = match[3];\r\n        if (value != null) value = value.trim();\r\n        else value = \"\";\r\n        if (name === \"include\") {\r\n          if (this.instructions[name] == null) this.instructions[name] = [];\r\n          (this.instructions[name] as string[]).push(value);\r\n        }\r\n        else\r\n          this.instructions[name] = value.trim().toLowerCase();\r\n      }\r\n      instructionsCount--;\r\n    }\r\n    while (match != null && instructionsCount > 0);\r\n  }\r\n\r\n  // ----------------------------------------\r\n\r\n  /**\r\n  * Gets the raw content of the asset.\r\n  */\r\n  getText(): string {\r\n    return this.__inner.text;\r\n  }\r\n\r\n  // ----------------------------------------\r\n\r\n  /**\r\n  * Returns the content of the asset, after having parsed and processed it\r\n  * @param options - An object with options.\r\n  * @return JavaScript or DOM object, or string.\r\n  */\r\n  parse(options?: { include?: boolean }): any {\r\n    options = options || {};\r\n    let extension = this.extension;\r\n\r\n    let parseFn = (text?: string): string => {\r\n      if (text == null)\r\n        text = this.__inner.text;\r\n\r\n      let parseFn: Function;\r\n      switch (extension) {\r\n        case \"json\":\r\n          parseFn = fText.parsers.jsonlint.parse;\r\n          break;\r\n        case \"cson\":\r\n          parseFn = fText.parsers.csonparser.parse;\r\n          break;\r\n        case \"html\":\r\n          parseFn = fText.parsers.domify;\r\n          break;\r\n        case \"md\":\r\n          parseFn = fText.parsers.markdown.toHTML;\r\n          break;\r\n        case \"pug\":\r\n          parseFn = fText.parsers.pug.compile(text);\r\n          break;\r\n        case \"styl\":\r\n          parseFn = () => { return; }; // special case\r\n          break;\r\n        case \"yml\":\r\n          parseFn = fText.parsers.jsyaml.safeLoad;\r\n          break;\r\n      }\r\n\r\n      if (parseFn != null) {\r\n        try {\r\n          if (extension === \"styl\")\r\n            text = fText.parsers.stylus(text).set(\"imports\", []).render();\r\n          else\r\n            text = parseFn(text);\r\n        }\r\n        catch (e) {\r\n          console.error(\"fText.parse(): error parsing asset '\" + this.__inner.name + \"' :\");\r\n          throw e;\r\n        }\r\n      }\r\n      return text;\r\n    };\r\n\r\n    let includeFn = (text?: string): string => {\r\n      if (text == null)\r\n        text = this.__inner.text;\r\n\r\n      if (this.instructions[\"include\"] != null) {\r\n        for (let path of this.instructions[\"include\"]) {\r\n          let asset = Sup.get(path, fText, {ignoreMissing: false}); // note: for some reason, the three arguments are needed here\r\n          let regexp = new RegExp(\"[<!/*#-]*ftext:include:\" + path.replace(\".\", \"\\\\.\") + \"[>*/-]*\", \"i\");\r\n          text = text.replace(regexp, asset.parse(options));\r\n        }\r\n      }\r\n      else if (options.include === true)\r\n        console.log(\"fText.parse(): Nothing to include for asset\", this.__inner.name);\r\n\r\n      return text;\r\n    };\r\n\r\n    if (options.include === false)\r\n      return parseFn();\r\n    else {\r\n      if (extension === \"html\" || extension === \"json\" || extension === \"cson\" || extension === \"yml\") {\r\n        return parseFn(includeFn());\r\n      }\r\n      else\r\n        return includeFn(parseFn());\r\n    }\r\n  }\r\n}\r\n\r\n(window as any).fText = fText;\r\n".replace("<reference path=", ""),
  defs: "// fText plugin\r\n// https://github.com/florentpoujol/superpowers-game-ftext-plugin\r\n// Adds a generic text asset of type FText\r\n\r\ndeclare class fText extends Sup.Asset {\r\n  constructor(inner: { [key: string]: any; });\r\n\r\n  static parsers: {\r\n    jsonlint: any,\r\n    csonparser: any,\r\n    domify: (text: string) => any,\r\n    markdown: any,\r\n    pug: any,\r\n    stylus: any,\r\n    jsyaml: any,\r\n  };\r\n\r\n  getText(): string;\r\n  parse(options?: {\r\n    include?: boolean,\r\n  }): any;\r\n}\r\n",
});

},{}]},{},[1]);
